namespace Python.Runtime.Native
{
    using System;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.InteropServices;

    static class ABI
    {
        internal static void Initialize(Version version, BorrowedReference pyType)
        {
            string offsetsClassSuffix = string.Format(CultureInfo.InvariantCulture,
                                                      "{0}{1}", version.Major, version.Minor);

            var thisAssembly = Assembly.GetExecutingAssembly();

            const string nativeTypeOffsetClassName = "Python.Runtime.NativeTypeOffset";
            string className = "Python.Runtime.TypeOffset" + offsetsClassSuffix;
            Type typeOffsetsClass =
                // Try platform native offsets first. It is only present when generated by setup.py
                thisAssembly.GetType(nativeTypeOffsetClassName, throwOnError: false)
                ?? thisAssembly.GetType(className, throwOnError: false);
            if (typeOffsetsClass is null)
            {
                var types = thisAssembly.GetTypes().Select(type => type.Name).Where(name => name.StartsWith("TypeOffset"));
                string message = $"Searching for {className}, found {string.Join(",", types)}. " +
                    "If you are building Python.NET from source, make sure you have run 'python setup.py configure' to fill in configured.props";
                throw new NotSupportedException($"Python ABI v{version} is not supported: {message}");
            }
            var typeOffsets = (ITypeOffsets)Activator.CreateInstance(typeOffsetsClass);
            TypeOffset.Use(typeOffsets);

            ManagedDataOffsets.Magic = Marshal.ReadInt32(pyType.DangerousGetAddress(), TypeOffset.tp_basicsize);
        }
    }
}
